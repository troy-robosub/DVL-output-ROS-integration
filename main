#!/usr/bin/python3

import argparse
import csv
import datetime
import json
import socket
import rospy
from time import sleep
#from std_msgs.msg import String
#from waterlinked_a50_ros_driver.msg import DVL //might have to change "waterlinked_a50 ros_driver" to my new fork bc the repo is archived. 
#from waterlinked_a50_ros_driver.msg import DVLBeam
import select

#workflow: work on reading through the parser script first. Look for important functions and classes. 
#Go to publisher next and do the same. Work on making sure that all the imports and libs work. 
class _CSVWriter:
    def __init__(self, csv_file, message_type):
        self.csv_file = csv_file
        self.csv_writer = self._csv_writer(csv_file, message_type)

    @classmethod
    def _csv_field_names(cls, message_type):
        if message_type == "velocity":
            return [
                "log_time",
                "time_of_validity",
                "time_of_transmission",
                "time",
                "vx",
                "vy",
                "vz",
                "fom",
                "altitude",
                "velocity_valid",
                "status" ]
        return [
            "log_time",
            "ts",
            "x",
            "y",
            "z",
            "std",
            "status" ]

    @classmethod
    def _csv_writer(cls, csv_file, message_type):
        csv_writer = csv.DictWriter(
            csv_file,
            fieldnames = cls._csv_field_names(message_type),
            extrasaction = "ignore",
            delimiter = ',')
        csv_writer.writeheader()
        return csv_writer

    def writerow(self, row):
        self.csv_writer.writerow(row)

    def flush(self):
        self.csv_file.flush()

""" 
looks like all of this is needed for parser. it sets environment for the csv file. from here, we'll take the csv file
and use it to publish the data. 

"""



def _start_dvl_socket(dvl_ip):
    dvl_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    dvl_socket.connect((dvl_ip, 16171))
    return dvl_socket
# used to start DVL by starting a TCP connection to the DVL. 
def _format_timestamp(timestamp, time_format):
    return datetime.datetime.strftime(
        datetime.datetime.fromtimestamp(timestamp),
        time_format)
def _format_timestamps(message_type, message, time_format):
    message["log_time"] = _format_timestamp(
        message["log_time"] / 1e6,
        time_format)
    if message_type == "velocity":
        try:
            message["time_of_validity"] = _format_timestamp(
                message["time_of_validity"] / 1e6,
                time_format)
            message["time_of_transmission"] = _format_timestamp(
                message["time_of_transmission"] / 1e6,
                time_format)
        except KeyError:
            pass
    else:
        message["ts"] = _format_timestamp(message["ts"], time_format)
#used to format the timestamps of the messages.
def _handle(message_type, message, time_format, csv_writer):
    if not message:
        return
    try:
        report = json.loads(message)
    except json.decoder.JSONDecodeError:
        print("Could not parse to JSON: " + message)
        return
    if report["type"] != message_type:
        return
    report["log_time"] = int(datetime.datetime.utcnow().timestamp() * 1e6)
    if time_format:
        _format_timestamps(message_type, report, time_format) # takes previous function and formats the timestamps.
    print(json.dumps(report))
    if csv_writer is not None:
        csv_writer.writerow(report)
        csv_writer.flush()
#used to handle the messages.

oldJson = ""

theDVL = DVL()
beam0 = DVLBeam()
beam1 = DVLBeam()
beam2 = DVLBeam()
beam3 = DVLBeam()


#inits the DVL and the beams. uses the DVL class and the DVLBeam class. probably will need to import it at the top of file.
